# 校园Java-OJ系统开发日志

## 2024-01-15 统一响应体与错误码系统开发

### 任务信息
- **任务类型**: 新功能
- **模块**: 通用工具包
- **优先级**: 高
- **预估工时**: 2小时

### 开发内容

#### 1. 统一错误码系统设计
创建了完整的错误码体系，按照业务模块进行分类：

**错误码规范**：
- 采用5位数字编码：AABBB
- AA: 模块代码 (10:通用, 20:用户, 30:题目, 40:提交, 50:判题, 60:管理, 70:竞赛)
- BBB: 具体错误代码 (001-999)

**主要错误码分类**：
```go
// 通用错误码 (10000-10999)
SUCCESS = 0
SYSTEM_ERROR = 10001
INVALID_PARAMS = 10002
UNAUTHORIZED = 10003
FORBIDDEN = 10004

// 用户模块错误码 (20000-20999)
USER_NOT_FOUND = 20001
USER_ALREADY_EXISTS = 20002
USERNAME_ALREADY_EXISTS = 20003
EMAIL_ALREADY_EXISTS = 20004

// 提交模块错误码 (40000-40999)
SUBMISSION_NOT_FOUND = 40001
CODE_TOO_LONG = 40004
DUPLICATE_SUBMISSION = 40007

// 判题模块错误码 (50000-50999)
JUDGE_SYSTEM_ERROR = 50001
COMPILE_ERROR = 50004
RUNTIME_ERROR = 50005
TIME_LIMIT_EXCEEDED = 50006
```

#### 2. 业务错误类型设计
创建了 `BusinessError` 结构体，支持：
- 错误码 (Code)
- 错误消息 (Message)
- 错误详情 (Detail)
- 实现 `error` 接口

#### 3. 统一响应体系统
根据用户需求，实现了统一的响应格式：

```go
type Response struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
    TraceID string      `json:"trace_id,omitempty"`
}

// 核心响应函数
func SendSuccess(c *gin.Context, data interface{})
func SendError(c *gin.Context, errCode int)
```

### 技术实现

#### 涉及文件
- `internal/pkg/errors/codes.go` - 错误码定义和消息映射
- `internal/pkg/errors/errors.go` - 业务错误类型和便捷构造函数
- `internal/pkg/utils/response.go` - 统一响应体和响应函数

#### 关键函数
1. **错误码管理**：
   - `GetErrorMessage(code int) string` - 获取错误消息
   - `IsUserError(code int) bool` - 判断错误类型

2. **业务错误构造**：
   - `New(code int, detail ...string) *BusinessError`
   - `Newf(code int, format string, args ...interface{}) *BusinessError`
   - `Wrap(code int, err error) *BusinessError`

3. **响应函数**：
   - `SendSuccess(c *gin.Context, data interface{})` - 成功响应
   - `SendError(c *gin.Context, errCode int)` - 错误响应
   - `SendBusinessError(c *gin.Context, err *BusinessError)` - 业务错误响应
   - `HandleError(c *gin.Context, err error)` - 统一错误处理

#### 使用示例

**成功响应**：
```go
// 返回用户信息
utils.SendSuccess(c, user)

// 响应格式
{
    "code": 0,
    "message": "成功",
    "data": {
        "id": "507f1f77bcf86cd799439011",
        "username": "zhangsan"
    }
}
```

**错误响应**：
```go
// 直接使用错误码
utils.SendError(c, errors.USER_NOT_FOUND)

// 使用业务错误
err := errors.NewUserNotFound("用户ID无效")
utils.SendBusinessError(c, err)

// 响应格式
{
    "code": 20001,
    "message": "用户不存在",
    "data": {
        "detail": "用户ID无效"
    }
}
```

**便捷错误构造**：
```go
// 预定义错误
return errors.NewUserNotFound()
return errors.NewInvalidPassword("密码长度不足")
return errors.NewDuplicateSubmission()

// 自定义错误
return errors.New(errors.JUDGE_TIMEOUT, "判题服务响应超时")
return errors.Newf(errors.CODE_TOO_LONG, "代码长度%d超过限制%d", len, limit)
```

### 代码规范遵循

1. **项目结构规范**：严格按照项目目录结构放置文件
2. **函数注释规范**：所有公开函数都有完整的中文注释
3. **错误处理规范**：统一的错误码和错误信息管理
4. **命名规范**：遵循Go语言命名约定

### 兼容性处理

为了保持向后兼容，保留了原有的响应函数：
- `SuccessResponse(c, message, data)` - 兼容老版本
- `ErrorResponse(c, statusCode, message, detail)` - 兼容老版本
- `ValidationErrorResponse(c, validationErrors)` - 参数验证错误

### 测试建议

#### 单元测试
- 测试错误码和消息映射的正确性
- 测试业务错误构造函数
- 测试响应格式的正确性

#### 集成测试
- 验证在实际HTTP请求中的响应格式
- 测试错误处理中间件的集成效果

### 后续优化计划

1. **国际化支持**：为错误消息添加多语言支持
2. **链路追踪**：完善TraceID的生成和传递
3. **监控集成**：添加错误码的监控和告警
4. **文档完善**：生成完整的错误码文档供前端开发参考

### 对前端的影响

**统一的响应格式**：
```typescript
interface ApiResponse<T = any> {
  code: number;      // 0表示成功，非0表示各种错误
  message: string;   // 错误描述信息
  data?: T;         // 响应数据，成功时包含实际数据，失败时可能包含detail
  trace_id?: string; // 链路追踪ID
}
```

**前端错误处理建议**：
```javascript
// 统一的API响应处理
const handleApiResponse = (response) => {
  if (response.code === 0) {
    // 成功处理
    return response.data;
  } else {
    // 错误处理
    const errorMessage = response.message;
    const errorDetail = response.data?.detail;
    
    // 根据错误码进行不同处理
    switch (response.code) {
      case 10003: // UNAUTHORIZED
        // 跳转登录页
        break;
      case 20001: // USER_NOT_FOUND
        // 显示用户不存在提示
        break;
      default:
        // 显示通用错误提示
        showError(errorMessage);
    }
  }
};
```

这个统一响应体系统为前后端提供了清晰、一致的交互接口，大大简化了错误处理和状态管理的复杂度。